_[homepage](../index.md)_

# 进程

## 进程
 - 进程是正在运行的**程序的实例**。是一个*具有一定独立功能的程序关于某个数据集合的一次运行活动*。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。
- 可以用_一个程序来创建多个进程_，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中**用户内存空间**包含了*程序代码及代码所使用的变量*，而**内核数据结构**则用于维*护进程状态信息*。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。

## 创建一个进程
**程序**是包含一系列信息的文件，这些信息描述了如何在运行时：
- 二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息解释文件中的其他信息。（ELF可执行连接格式）
- 机器语言指令：对程序算法进行编码。
- 程序入口地址：标识程序开始执行时的起始指令位置。
- 数据：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。
- 符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。
- 共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。
- 其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。

## 单道、多道程序设计
- 单道程序，即在计算机内存中只允许一个的程序运行。
- 多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，*相互穿插运行*，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序*共享计算机系统资源*。引入多道程序设计技术的根本目的是为了**提高 CPU 的利用率**。
- 对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就*微观而言，任意时刻，CPU 上运行的程序只有一个*。
- 在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。

## 时间片
- 时间片（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。事实上，虽然一台计算机通常可能有多个 CPU，但是同一个 CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在 Linux 上为 5ms－800ms），用户不会感觉到。
- 时间片由操作系统*内核的调度程序分配*给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。

## 并行和并发
- **并行(parallel)**：指在同一时刻，有多条指令在多个处理器上**同时**执行。
- **并发(concurrency)**：指在**同一时刻只能有一条指令执行**，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。

## 进程控制块PCB
- 为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个 PCB(Processing Control Block)进程控制块，维护进程相关的信息，Linux 内核的进程控制块是 *task_struct 结构体*。
- 在 /usr/src/linux-headers-xxx/include/linux/sched.h 文件中可以查看 struct task_struct 结构体定义。其内部成员有很多，我们只*需要掌握以下部分即可*：
	- 进程*id*：系统中每个进程有唯一的 id，用 pid_t 类型表示，其实就是一个非负整数
	- 进程的*状态*：有就绪、运行、挂起、停止等状态
	- 进程切换时需要保存和恢复的一些*CPU寄存器*
	- 描述*虚拟地址空间的信息*
	- 描述控制*终端的*信息
	- *当前工作目录*（Current Working Directory）
	- *umask* 掩码
	- *文件描述符表*，包含很多指向 file 结构体的指针
	- 和*信号*相关的信息
	- *用户 id 和组 id*
	- *会话（Session）和进程组*
	- 进程可以使用的*资源上限（Resource Limit）*

## 进程的状态
<img width="1230" alt="image" src="https://user-images.githubusercontent.com/41602569/156754769-65853b64-a87b-45af-a084-c0d97f99e05f.png">
<img width="1230" alt="image" src="https://user-images.githubusercontent.com/41602569/156754972-d9374baa-cf05-4b81-9bde-9644d29d6adc.png">

### 查看进程 `ps aux / ajx` 
- a:显示终端上的所有进程，包括其他用户的进程 
- u:显示进程的详细信息 STAT 进程状态
- x:显示没有控制终端的进程 
- j:列出与作业控制相关的信息,会显示父进程PPID

### `top` 可以实时的更新进程信息，-d 每几秒更新一次，还可以对现实结果进行排序：
	- M	根据内存使用量
	- P CUP占有率
	- T 进程运行时长
	- U 用户名筛选进程
	- K 杀死指定的PID进程
### `kill`:
- kill -signal pid 
- kill –l 列出所有信号 
- kill –SIGKILL 进程ID 
- kill -9 进程ID
- killall name 根据进程名杀死进程

## 进程号和相关函数
- 每个进程都由进程号来标识，其类型为 **pid_t**(整型)，进程号的范围:0~32767。 进程号总**是唯一的，但可以重用**。当一个进程终止后，其进程号就可以再次使用。
- __任何进程(除 init 进程)都是由另一个进程创建__，该进程称为被创建进程的父进程， 对应的进程号称为父进程号(PPID)。
- **进程组是一个或多个进程的集合**。他们之间相互关联，进程组**可以接收同一终端的各种信号**，关联的进程有一个进程组号(**PGID**)。默认情况下，当前的进程号会当做当前的进程组号。
- 进程号和进程组相关函数:
	 - pid_t getpid(void);
	 - pid_t getppid(void);
	 - pid_t getpgid(**pid_t** pid);
